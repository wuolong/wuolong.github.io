<h1 id="introduction">Introduction</h1>
<p>Learning <a href="https://julialang.org">Julia</a> follow the book <a href="https://statisticswithjulia.org">Statistics with Julia</a>.</p>
<h2 id="setup-and-interface">Setup and Interface</h2>
<p>Instead of <a href="https://github.com/JuliaLang/IJulia.jl">Jupyter Notebook</a>, My preference is Emacs. Thankfully, with <a href="https://ess.r-project.org">ESS</a> supporting Julia and <a href="https://polymode.github.io">Polymode</a>, it is seamless to run the codes interactively. With <a href="http://weavejl.mpastell.com/stable/">Weave.jl</a>, PDF or HTML output can be generated as needed. Note that Weave.jl puts all the output of each chunk together, instead of immediate following each line as in RMarkdown/knitr.</p>
<pre class="elisp"><code>(use-package julia-mode)
(use-package ess
  :mode ((&quot;\\.jl\\&#39;&quot; . ess-julia-mode)))
(use-package poly-markdown
  :ensure t
  :mode ((&quot;\\.[jJ]md\\&#39;&quot; . poly-markdown-mode)))
(add-to-list &#39;polymode-mode-name-override-alist &#39;(julia . ess-julia))
(require &#39;smart-compile) ;; https://github.com/zenitani/elisp/blob/master/smart-compile.el
(global-set-key (kbd &quot;&lt;f8&gt;&quot;) &#39;smart-compile)
(add-to-list &#39;smart-compile-alist &#39;(&quot;\\.[jJ]md\\&#39;&quot; . &quot;julia -e &#39;using Weave; weave(\&quot;%f\&quot;)&#39;&quot;))</code></pre>
<h2 id="julia-vs-r">Julia vs R</h2>
<p>Julia was designed from the ground-up as a high-performance scientific computation language using just-in-time (JIT) compilation, with built-in arrays (vector, matrix).</p>
<p>Coming from an R background, it is helpful to note some rather "peculiar" aspects of Julia that contributes to its high-performance:</p>
<ul>
<li><p>Julia has rather strong type system. A function needs to know its argument types for <em>multiple dispatch</em> to work. Sometimes explicit type conversion (e.g., from integer to float) is required.</p></li>
<li><p>Unlike R, arrays are always passed by reference to avoid memory allocation and copying.</p></li>
<li><p>In addition to functions, loops (<code>for</code> or <code>while</code>) define their own scopes.</p></li>
<li><p>A functions is not automatically "vectorized" if not defined to take an array as argument. Instead the <em>dot operator</em> is needed to "broadcast" a function to each element of an array.</p></li>
<li><p>Julia also has built-in support for <strong>macros</strong> which can be convenient.</p></li>
</ul>
<p>Examples:</p>
<pre class="{.julia}"><code>a = [1 3 4];
b = [0.2 0.3 -0.3];
a + b                           # this is vectorized</code></pre>
<pre><code>1×3 Array{Float64,2}:
 1.2  3.3  3.7</code></pre>
<p>This does not work:</p>
<pre class="{.julia}"><code>try
    sin(a)
catch
    println(&quot;sin() does not have a method for Array type&quot;)
end</code></pre>
<pre><code>sin() does not have a method for Array type</code></pre>
<p>This does:</p>
<pre class="{.julia}"><code>sin.(a)</code></pre>
<pre><code>1×3 Array{Float64,2}:
 0.841471  0.14112  -0.756802</code></pre>
<pre class="{.julia}"><code>macro sayhello(name)
    return :( println(&quot;Hello, &quot;, $name, &quot;!&quot;) )
end
@sayhello &quot;Charlie&quot;</code></pre>
<pre><code>Hello, Charlie!</code></pre>
<h2 id="language-overview">Language Overview</h2>
<p>One peculiarity of Julia is that in a function call (e.g., <code>println()</code>) the left parenthesis must immediately follow the function name. Space is not allowed. Perhaps this is to make the code easier to parse for the just-in-time compiler?</p>
<p>The semicolon <code>;</code> at the end suppresses the output.</p>
<p>One basic data type is <code>Array</code>. Note that in Julia, array index starts at 1 (just as R, Matlab or FORTRAN, but unlike Python or C).</p>
<pre class="{.julia}"><code>println(&quot;There is more than one way to say hello:&quot;)
helloArray = [&quot;Hello&quot;, &quot;G&#39;day&quot;, &quot;Shallom&quot;];
typeof(helloArray)
for i in 1:3
    println(&quot;\t&quot;, helloArray[i], &quot; World!&quot;)
end</code></pre>
<pre><code>There is more than one way to say hello:
    Hello World!
    G&#39;day World!
    Shallom World!</code></pre>
<p>Comprehension <code>[f(x) for x in A]</code> is a short hand for constructing a list or an array. The "dot" notation "broadcasts" the function to every element of the array.</p>
<pre class="{.julia}"><code>println(&quot;\nThese squares are just perfect:&quot;)
squares = [i^2 for i in 0:10]
for s in squares
    println(&quot;  &quot;, s)
end</code></pre>
<pre><code>These squares are just perfect:
  0
  1
  4
  9
  16
  25
  36
  49
  64
  81
  100</code></pre>
<pre class="{.julia}"><code>sqrt.(squares)</code></pre>
<pre><code>11-element Array{Float64,1}:
  0.0
  1.0
  2.0
  3.0
  4.0
  5.0
  6.0
  7.0
  8.0
  9.0
 10.0</code></pre>
<h3 id="types-and-methods">Types and Methods</h3>
<p>More examples of comprehension. Julia has a strong type system, which all variables have types (<code>Int64</code> or <code>Float64</code>) which helps the compiler. <code>UnitRange</code> is a special type of objects. The last line of the code creates a "tuple", which is immutable. The parentheses are optional.</p>
<pre class="{.julia}"><code>array1 = [(2n+1)^2 for n in 1:5]
array2 = [sqrt(i) for i in array1]
array1 + array2
println(typeof(1:5), &quot;, &quot;, typeof(array1), &quot;, &quot;, typeof(array2))
tp1 = 1:5, array1, array2
tp2 = (1:5, array1, array2)
tp1[2]</code></pre>
<pre><code>UnitRange{Int64}, Array{Int64,1}, Array{Float64,1}
5-element Array{Int64,1}:
   9
  25
  49
  81
 121</code></pre>
<pre class="{.julia}"><code>try
    tp2[2] = 3                       # error
catch
    println(&quot;Cannot change elements of a tuple.&quot;)
end</code></pre>
<pre><code>Cannot change elements of a tuple.</code></pre>
<p>Julia functions are <strong>generic</strong> and have different <em>methods</em> depending on the type of the inputs using <em>multiple dispatch</em>.</p>
<pre class="{.julia}"><code>methods(sqrt)</code></pre>
<pre><code># 20 methods for generic function &quot;sqrt&quot;:
[1] sqrt(::Missing) in Base.Math at math.jl:1197
[2] sqrt(a::Float16) in Base.Math at math.jl:1144
[3] sqrt(x::BigInt) in Base.MPFR at mpfr.jl:573
[4] sqrt(a::Complex{Float16}) in Base.Math at math.jl:1145
[5] sqrt(x::BigFloat) in Base.MPFR at mpfr.jl:565
[6] sqrt(z::Complex{var&quot;#s91&quot;} where var&quot;#s91&quot;&lt;:AbstractFloat) in Base at c
omplex.jl:481
[7] sqrt(z::Complex) in Base at complex.jl:506
[8] sqrt(x::Union{Float32, Float64}) in Base.Math at math.jl:572
[9] sqrt(x::Real) in Base.Math at math.jl:599
[10] sqrt(A::StridedArray{var&quot;#s828&quot;, 2} where var&quot;#s828&quot;&lt;:Real) in LinearA
lgebra at /Applications/Julia-1.5.app/Contents/Resources/julia/share/julia/
stdlib/v1.5/LinearAlgebra/src/dense.jl:744
[11] sqrt(A::StridedArray{var&quot;#s828&quot;, 2} where var&quot;#s828&quot;&lt;:Complex) in Line
arAlgebra at /Applications/Julia-1.5.app/Contents/Resources/julia/share/jul
ia/stdlib/v1.5/LinearAlgebra/src/dense.jl:757
[12] sqrt(A::LinearAlgebra.UpperTriangular) in LinearAlgebra at /Applicatio
ns/Julia-1.5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/LinearAlg
ebra/src/triangular.jl:2577
[13] sqrt(A::LinearAlgebra.UpperTriangular{T,S} where S&lt;:AbstractArray{T,2}
, ::Val{realmatrix}) where {T, realmatrix} in LinearAlgebra at /Application
s/Julia-1.5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/LinearAlge
bra/src/triangular.jl:2597
[14] sqrt(A::LinearAlgebra.UnitUpperTriangular{T,S} where S&lt;:AbstractArray{
T,2}) where T in LinearAlgebra at /Applications/Julia-1.5.app/Contents/Reso
urces/julia/share/julia/stdlib/v1.5/LinearAlgebra/src/triangular.jl:2617
[15] sqrt(A::LinearAlgebra.LowerTriangular) in LinearAlgebra at /Applicatio
ns/Julia-1.5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/LinearAlg
ebra/src/triangular.jl:2635
[16] sqrt(A::LinearAlgebra.UnitLowerTriangular) in LinearAlgebra at /Applic
ations/Julia-1.5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/Linea
rAlgebra/src/triangular.jl:2636
[17] sqrt(A::LinearAlgebra.Hermitian{T,S} where S&lt;:(AbstractArray{var&quot;#s828
&quot;,2} where var&quot;#s828&quot;&lt;:T); rtol) where T&lt;:Complex in LinearAlgebra at /Appl
ications/Julia-1.5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/Lin
earAlgebra/src/symmetric.jl:1025
[18] sqrt(A::Union{LinearAlgebra.Hermitian{T,S}, LinearAlgebra.Symmetric{T,
S}} where S; rtol) where T&lt;:Real in LinearAlgebra at /Applications/Julia-1.
5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/LinearAlgebra/src/sy
mmetric.jl:1014
[19] sqrt(D::LinearAlgebra.Diagonal) in LinearAlgebra at /Applications/Juli
a-1.5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/LinearAlgebra/sr
c/diagonal.jl:576
[20] sqrt(J::LinearAlgebra.UniformScaling) in LinearAlgebra at /Application
s/Julia-1.5.app/Contents/Resources/julia/share/julia/stdlib/v1.5/LinearAlge
bra/src/uniformscaling.jl:139</code></pre>
<h3 id="performance-timing">Performance Timing</h3>
<p>Timing of codes using a macro (<code>@</code> construct).</p>
<p>For the <code>mean()</code> function:</p>
<pre class="{.julia}"><code>using Statistics</code></pre>
<p>Compute 1 million times of the mean of 500 random numbers, where as the random numbers are generated one at a time.</p>
<pre class="{.julia}"><code>@time begin
    data = Float64[]
    for _ in 1:10^6
        group = Float64[]
        for _ in 1:5 * 10^2
            push!(group, rand())
        end
        push!(data, mean(group))
    end
    println(&quot;98% of the means lie in the estimated range: &quot;,
            (quantile(data, 0.01), quantile(data, 0.99)))
end</code></pre>
<pre><code>98% of the means lie in the estimated range: (0.46992989014932895, 0.530059
0104271407)
  6.442453 seconds (10.41 M allocations: 7.995 GiB, 8.60% gc time)</code></pre>
<p>Note that the function <code>push!()</code> use the <code>!</code> naming convention to indicate that the function modifies its argument.</p>
<p>This is much faster to generate 500 random numbers at once.</p>
<pre class="{.julia}"><code>@time begin
    data = [mean(rand(5 * 10^2)) for _ in 1:10^6]
    println(&quot;98% of the means lie in the estimated range: &quot;,
            (quantile(data, 0.01), quantile(data, 0.99)))
end</code></pre>
<pre><code>98% of the means lie in the estimated range: (0.4700013445856619, 0.5300801
76437303)
  1.550398 seconds (1.12 M allocations: 3.903 GiB, 20.29% gc time)</code></pre>
<h3 id="variable-scope">Variable Scope</h3>
<p>Sometimes it is necessary to use the <code>global</code> keyword. Note here a loop (<code>for</code> or <code>while</code>) has its own scope and the variable <code>i</code> is only available inside the loop.</p>
<pre class="{.julia}"><code>data = [1, 2, 3];
s = 0;
beta, gamma = 2, 1;
for i in 1:length(data)
    print(i, &quot; &quot;)
    global s;                   # may not be needed
    s += beta * data[i];
    data[i] *= -1;
end
println(&quot;\nSum of data in external scope: &quot;, s)</code></pre>
<pre><code>1 2 3 
Sum of data in external scope: 12</code></pre>
<p>A function has its scope.</p>
<pre class="{.julia}"><code>function sumData(beta)
    s = 1
    for i in 1:length(data)
        s += data[i] + beta     # local variable beta
    end
    return s
end
println(&quot;Sum of data in a function: &quot;, sumData(beta / 2))
@show s                         # this shows global s</code></pre>
<pre><code>Sum of data in a function: -2.0
s = 12
12</code></pre>
<h2 id="crush-course">Crush Course</h2>
<h3 id="bubble-sort">Bubble Sort</h3>
<p>Note the convention of including <code>!</code> in the function name that changes its argument. Also note that <code>1:n-1</code> is the same as <code>1:(n-1)</code>, i.e., <code>:</code> operator seems to always evaluate the last.</p>
<pre class="{.julia}"><code>function bubbleSort!(a)
    n = length(a)
    for i in 1:n-1
        for j in 1:n-i
            if a[j] &gt; a[j+1]
                a[j], a[j+1] = a[j+1], a[j]
            end
        end
    end
    return a
end
data = [65, 51, 32, 12, 23, 84, 68, 1]
typeof(data)
bubbleSort!(data)</code></pre>
<pre><code>8-element Array{Int64,1}:
  1
 12
 23
 32
 51
 65
 68
 84</code></pre>
<p>By default the function argument <code>a</code> is of <code>Array</code> type and it works for whatever elements in the array. In Julia, by default arrays are <em>passed by reference</em> so can be changed in place.</p>
<pre class="{.julia}"><code>data2 = [65, 51, 32, 12, 23, 84, 68, 1.0]
typeof(data2)
bubbleSort!(data2)</code></pre>
<pre><code>8-element Array{Float64,1}:
  1.0
 12.0
 23.0
 32.0
 51.0
 65.0
 68.0
 84.0</code></pre>
<h3 id="roots-of-a-polynomial">Roots of a Polynomial</h3>
<p>Here we define a function that returns a (polynomial) function. An argument, <code>a</code>, along with the <em>splat operator</em> <code>...</code> indicates that the function will accept a comma separated list of parameters of unspeciﬁed length.</p>
<pre class="{.julia}"><code>function polynomialGenerator(a...)
    n = length(a)-1
    poly = function(x)
        return sum([a[i+1] * x^i for i in 0:n])
    end
    return poly
end
polynomial = polynomialGenerator(1,3,-10);
polynomial(3.23)</code></pre>
<pre><code>-93.63900000000001</code></pre>
<p>Functions can be passed as arguments to other functions. Here the <code>find_zeros()</code> function in <code>Roots</code> package is used to solve the roots.</p>
<pre class="{.julia}"><code>using Roots
zeroVals = find_zeros(polynomial,-10,10);
println(&quot;Zeros of the function f(x): &quot;, zeroVals)</code></pre>
<pre><code>Zeros of the function f(x): [-0.19999999999999998, 0.5]</code></pre>
<h3 id="markov-chain">Markov Chain</h3>
<p>This example shows some linear algebra and simulations. In Julia, a matrix is defined in the same way as in Matlab.</p>
<pre class="{.julia}"><code>P = [0.5 0.4 0.1;
     0.3 0.2 0.5;
     0.5 0.3 0.2];
typeof(P)
size(P)                         # dimension of the matrix
length(P)</code></pre>
<pre><code>9</code></pre>
<p>Basic linear algebra operators are defined in an intuitive fashion. The notation <code>[1,:]</code> takes the first row which is a one-dimensional array. Here the goal is to obtain the stationary distribution.</p>
<p>$$\pi_i = \lim_{n\rightarrow \infty} [P^n]_{j,i}, \quad \text{for any} j.$$</p>
<pre class="{.julia}"><code>piProb1 = (P^100)[1,:];</code></pre>
<p>A second way is to solve the linear systems of equations:</p>
<p>$$\pi P = \pi$$</p>
<p>$$\sum_{i=1}^3 \pi_i = 1$$</p>
<p><code>vcat</code> is for <em>vertical concatenation</em> or adding rows.</p>
<pre class="{.julia}"><code>using LinearAlgebra             # for I, and eigvecs()
P&#39;                              # transpose
I                               # a special bulitin unit matrix
ones(3)                         # a handy function
A = vcat((P&#39; - I)[1:2,:], ones(3)&#39;)
b = [0 0 1]&#39;
piProb2 = A \ b;</code></pre>
<p>Note that when an array is assigned to another, it is only by reference so both point to the same memory. To copy the values into a completely new array, use the <code>copy()</code> function</p>
<pre class="{.julia}"><code>a = [1 2 3]
b = a;
c = copy(a);
b[2] = 20;
println(&quot;a = &quot;, a)              # a is changed
c[2] = 343;
println(&quot;a = &quot;, a)              # not changed
println(&quot;c = &quot;, c)</code></pre>
<pre><code>a = [1 20 3]
a = [1 20 3]
c = [1 343 3]</code></pre>
<p>A third method makes use of the <em>Perron Frobenius Theorem</em> (?) which implies the eigenvector corresponding to the eigenvalue of maximal magnitude is proportional to $\pi$, we ﬁnd this eigenvector and normalize it by the sum of probabilities ($L_1$ norm). Note that these functions return complex values that have to be casted to float.</p>
<pre class="{.julia}"><code>eigVecs = eigvecs(copy(P&#39;))
highestVec = eigVecs[:, findmax(abs.(eigvals(P)))[2]]
piProb3 = Array{Float64}(highestVec) / norm(highestVec, 1);</code></pre>
<p>Lastly a simulation is used.</p>
<pre class="{.julia}"><code>using StatsBase                 # for sample(), weights()
numInState = zeros(Int,3)
state = 1;
N = 10^6;
for t in 1:N
    numInState[state] += 1
    global state = sample(1:3, weights(P[state,:]))
end
piProb4 = numInState / N;</code></pre>
<p>Show all the results. Note how the vectors are combined into columns of a matrix.</p>
<pre class="{.julia}"><code>[piProb1 piProb2 piProb3 piProb4]</code></pre>
<pre><code>3×4 Array{Float64,2}:
 0.4375  0.4375  0.4375  0.437591
 0.3125  0.3125  0.3125  0.312844
 0.25    0.25    0.25    0.249565</code></pre>
